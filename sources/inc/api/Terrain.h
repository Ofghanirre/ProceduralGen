//
// Created by Antonin Jean on 28/01/2024.
//

#pragma once
#include "noise/INoiseGenerator.h"
#include "noise/Noise.h"
#include "noise/punderations/NoisePunderationFunctions.h"
/**
 * @brief A Terrain is a collection of NoiseGenerator, each of them being mapped to a function
 * The function is used to punderate the noise generated by the NoiseGenerator
*/
struct TerrainNode {
    TerrainNode(INoiseGenerator& _noiseGenerator, IPunderationFunction& _mappingFunction, bool (*_predicate)(int)): noiseGenerator(_noiseGenerator), mappingFunction(_mappingFunction), predicate(_predicate) {};

    INoiseGenerator& noiseGenerator;
    IPunderationFunction& mappingFunction;
    bool (*predicate)(int);
};

enum NoisePunderationFunction {
    IDENTITY,
    INVERSE,
    SQUARE,
    CUBE,
    SQUARE_ROOT,
    ABS,
};

static auto NoisePunderation_Identity = IdentityPunderationFunction();
static auto NoisePunderation_Inverse = ProductPunderationFunction<int>(-1);
static auto NoisePunderation_Square = PowerPunderationFunction(2);
static auto NoisePunderation_Cube = PowerPunderationFunction(3);
static auto NoisePunderation_SquareRoot = PowerPunderationFunction(0.5);
static auto NoisePunderation_Abs = AbsPunderationFunction();

/**
 * @brief A Terrain is a structure representing a compilation of NoiseGenerator
 * Each and every NoiseGenerator is mapped to a function that will be used to punderate the noise generated by the NoiseGenerator
 */
class Terrain {
public:
    explicit Terrain(std::string name, size_t seed): m_name(name), m_seed(seed) {};

    /**
     * @brief Adds a NoiseGenerator to the Terrain
     * @param noiseGenerator the NoiseGenerator to add
     * @param mappingFunction the function to map the noise generated by the NoiseGenerator
     */
    void addTerrainNode(INoiseGenerator& noiseGenerator, IPunderationFunction& mappingFunction, bool (*predicate)(int) = [](int value) {return true;}) {
        m_terrainNodes.push_back({noiseGenerator, mappingFunction, predicate});
    }

    void addTerrainNode(INoiseGenerator& noiseGenerator, NoisePunderationFunction eFunction = IDENTITY, bool (*predicate)(int) = [](int value) {return true;}) {
        switch(eFunction) {
            case (IDENTITY): {
                return addTerrainNode(noiseGenerator, NoisePunderation_Identity, predicate);
            }
            case (INVERSE): {
                return addTerrainNode(noiseGenerator, NoisePunderation_Inverse, predicate);
            }
            case (SQUARE): {
                return addTerrainNode(noiseGenerator, NoisePunderation_Square, predicate);
            }
            case (CUBE): {
                return addTerrainNode(noiseGenerator, NoisePunderation_Cube, predicate);
            }
            case (SQUARE_ROOT): {
                return addTerrainNode(noiseGenerator, NoisePunderation_SquareRoot, predicate);
            }
            case (ABS): {
                return addTerrainNode(noiseGenerator, NoisePunderation_Abs, predicate);
            }
            default:
                throw std::runtime_error("Unknown NoisePunderationFunction");
        }
    }

    const std::string &getName() const {
        return m_name;
    }

    const std::vector<TerrainNode> &getTerrainNodes() const {
        return m_terrainNodes;
    }

    /**
     * @brief Generates a bitmap of the terrain
     * @param width the width of the bitmap
     * @param height the height of the bitmap
     * @param frequency the frequency of the bitmap
     * @return the bitmap of the terrain
     */
    Noise getTerrain(size_t width, size_t height, size_t frequency) {
        BitMap<int> bitmap(width, height, 0);
        for (TerrainNode &terrainNode : m_terrainNodes) {
            Noise noise = terrainNode.noiseGenerator.genNoise(m_seed, width, height, frequency);
            for (int h = 0; h < height; ++h) {
                for (int w = 0; w < width; ++w) {
                    int v = bitmap.get(w,h);
                    if (terrainNode.predicate(v) == false) {
                        continue;
                    }
                    int value = noise.getBitmap().get(w, h);
                    bitmap.put(w, h, bitmap.get(w,h) + terrainNode.mappingFunction.compute(value));
                }
            }
        }
        return Noise(bitmap, m_seed, width, height, frequency);
    }

private:
    const size_t m_seed;
    std::string m_name;
    std::vector<TerrainNode> m_terrainNodes;
};
